import mealModel from './MealModel.js';
import mealView from './MealView.js';

export default class mealController {
    constructor () {
        this.modelItems = new mealModel('items');
        this.modelRecipes = new mealModel('recipes');
        this.modelMenus = new mealModel('menus');
        this.view = new mealView();
    }

    // lists the inventory
    listItems() {
        const inventory = this.modelItems.getItems();
        const listElement = document.getElementById('listInventory');

        listElement.innerHTML = this.view.renderItemHeading();

        let IDcounter = 0; // used to provide a different ID for each button generated by renderItem

        inventory.forEach(item => {
            IDcounter++;
            const newItem = this.view.renderItem(item, IDcounter);
            listElement.appendChild(newItem);
        });
    }

    // this is the code that generates the row to dd items to the inventory
    addItem() {
        const addItemBar = document.getElementById('addItemTable');
        addItemBar.innerHTML = '';

        const addItemBarRow = document.createElement('tr');
        addItemBarRow.innerHTML = this.view.renderAddItem();

        addItemBar.appendChild(addItemBarRow);
    }

    // this adds the item to the inventory
    addIndividualItem() {
        let item = [];
        let itemName = document.getElementById('addIndividualItemName').value;
        let itemQuantity = document.getElementById('addIndividualItemQuantity').value;

        item.name = itemName;
        item.quantity = itemQuantity;

        this.modelItems.add(item);

        location.reload(); // refreshing the page because we need to re-add the event listeners for the new buttons
    }

    // deletes an item at a specified position
    deleteItem(position) {
        const inventory = this.modelItems.getItems();
        this.modelItems.delete(inventory[position]);

        location.reload(); // refreshing the page because we need to re-add the event listeners for the new buttons
    }

    // edits a specific item. If the name is found, it simply changes the rest of the properties. If the name was 
    // not found (name was the one that actually changed), then we delete the current item completely, and add a new one
    editItem(position) {
        const inventory = this.modelItems.getItems();

        // generate a new table
        const listElement = document.getElementById('listInventory');
        listElement.innerHTML = this.view.renderItemHeading();

        // list the items like normal up until our item to be edited
        let IDcounter = 0;
        let i = 0;
        for (i; i < position; i++) {
            IDcounter++;
            let newItem = this.view.renderItem(inventory[i], IDcounter);
            listElement.appendChild(newItem);
        }

        // list the current element with edit boxes
        let editedItem = this.view.renderEditItem(inventory[position])
        listElement.appendChild(editedItem);

        // finish displaying the rest of the table like normal
        IDcounter++;
        for (i++; i < inventory.length; i++) {
            IDcounter++;
            let newItem = this.view.renderItem(inventory[i], IDcounter);
            listElement.appendChild(newItem);
        }

        // add event listener for the Finish button
        let modelItems = this.modelItems; // for some reason, i can not use this.modelItems in the if statement below. it says it's undefined so i defined it again here
        document.addEventListener("touchend", function (finishEditItemButton) {
            if (finishEditItemButton.target && finishEditItemButton.target.id == 'editedItemFinishID') {
                const itemName = document.getElementById('editedItemNameID').value;
                const itemQuantity = document.getElementById('editedItemQuantityID').value;
                let itemTobeEdited = {name: itemName, quantity: itemQuantity};
                modelItems.edit(itemTobeEdited, position);

                location.reload();
            }
        });
    }

    // lists the existing recipes
    listRecipes() {
        const inventory = this.modelRecipes.getItems();
        const listRecipes = document.getElementById('listRecipes');

        let IDcounter = 0; // used to generate differnt IDs for the buttons generated here
        inventory.forEach(recipe => {
            IDcounter++;
            const newRecipe = this.view.renderRecipe(recipe, IDcounter);
            listRecipes.appendChild(newRecipe);
        });
    }

    // this metod does not actualy add a recipe. It only generates the table to add a recipe. A temporary recipe is
    // stored as information is added. When the 'Finish' button is pressed, the temporary recipe is added to the actual local storage
    addRecipe() {
        const addRecipeTable = document.getElementById('addRecipeTable');
        addRecipeTable.innerHTML = '';

        const temporaryRecipe = this.modelRecipes.getTemporaryRecipe();

        // generate the head of the table (recipe name)
        const addRecipeTableHead = document.createElement('tr');
        addRecipeTableHead.innerHTML = this.view.renderAddRecipe(temporaryRecipe.name);
        addRecipeTable.appendChild(addRecipeTableHead);

        // generate the temporary recipe ingredients
        const temporaryRecipeIngredients = temporaryRecipe.ingredients;
        let IDCounter = 0;
        temporaryRecipeIngredients.forEach(ingredient => {
            IDCounter++;
            const newIngredient = this.view.renderIndividualIngredient(ingredient, IDCounter);
            addRecipeTable.appendChild(newIngredient);
        });

        // generate the temporary recipe description
        const addRecipeDescription = document.createElement('tr');
        addRecipeDescription.innerHTML = this.view.renderAddDescription(temporaryRecipe.description);
        addRecipeTable.appendChild(addRecipeDescription);

        // add event listener for the - buttons (within the Add Ingredient section for adding a new Recipe)
        let removeTemporaryIngredientButtons = document.getElementsByClassName("removeTemporaryIndividualIngredientButtonClass");
        let self = this;
        for (let i = 0; i < removeTemporaryIngredientButtons.length; i++) {
            removeTemporaryIngredientButtons[i].addEventListener("touchend", function () {
                self.removeTemporaryIndividualIngredient(i);
            });
        }  
    }

    // this method does not actualy add the ingredient to the temporary recipe. It only generates the table to do so
    addTemporaryIngredient() {
        const newRecipeName = document.getElementById('addRecipeName').value;
        this.modelRecipes.storeNewRecipeName(newRecipeName);

        const newRecipeDescription = document.getElementById('temporaryRecipeDescriptionID').value;
        this.modelRecipes.storeNewRecipeDescription(newRecipeDescription);

        this.addRecipe(); // we're re-creating the table to avoid adding multiple empty ingredients rows
        const addRecipeTable = document.getElementById('addRecipeTable');

        const addRecipeIngredient = document.createElement('tr');
        addRecipeIngredient.innerHTML = this.view.renderAddRecipeIngredient();

        addRecipeTable.appendChild(addRecipeIngredient);
    }

    // this method adds the temporary ingredient to the temporary recipe
    addTemporaryIndividualIngredient() {
        const newIngredientName = document.getElementById('addIndividualIngredientNameID').value;
        const newIngredientQuantity = document.getElementById('addIndividualIngredientQuantityID').value;

        const newIngredient = {
            name: newIngredientName,
            quantity: newIngredientQuantity
        };

        this.modelRecipes.storeNewIngredientInTempRecipe(newIngredient);

        this.addRecipe(); // we're re-drawing the current table 
    }

    // removes a temporary ingredient from the temporary recipe (this is while adding a recipe)
    removeTemporaryIndividualIngredient(position) {
        this.modelRecipes.deleteTemporaryIndividualIngredient(position);

        this.addRecipe(); // we're re-drawing the current table
    }

    // this method actually adds the temporary recipe into the local storage
    addIndividualRecipe() {
        const newRecipeDescription = document.getElementById('temporaryRecipeDescriptionID').value;
        this.modelRecipes.storeNewRecipeDescription(newRecipeDescription);
        this.modelRecipes.addRecipe();
        location.reload();
    }

    // generates the recipe in edit mode. This method takes the position of the recipe to be edited, later used as reference
    editDeleteRecipe(position) {
        const recipes = this.modelRecipes.getItems();
        const recipeTables = document.getElementById('listRecipes');
        recipeTables.innerHTML = '';

        // generate tables like normal up until our current one
        let i = 0;
        let IDcounter = 0;
        for(i; i < position; i++) {
            IDcounter++;
            const newRecipe = this.view.renderRecipe(recipes[i], IDcounter);
            recipeTables.appendChild(newRecipe);
        }

        // generate our current recipe in edit mode
        let editedRecipe = this.view.renderEditRecipe(recipes[position]);
        recipeTables.appendChild(editedRecipe);

        // generate the rest of the table like normal
        IDcounter++;
        for (i++; i < recipes.length; i++) {
            IDcounter++;
            const newRecipe = this.view.renderRecipe(recipes[i], IDcounter);
            recipeTables.appendChild(newRecipe);
        }

        let self = this;

        // add event listener to the delete for good button
        document.addEventListener("touchend", function (deleteIndividualRecipeButton) {
            if (deleteIndividualRecipeButton.target && deleteIndividualRecipeButton.target.id == 'deleteTheRecipeForGoodButtonID') {
                const recipeName = document.getElementById('editedRecipeNameID').value;
                self.deleteRecipeForGood(recipeName);
            }
        });

        // add event listener to the Finish Editing button
        document.addEventListener("touchend", function (finishEditIndividualRecipeButton) {
            if (finishEditIndividualRecipeButton.target && finishEditIndividualRecipeButton.target.id == 'finishEditRecipeButtonID') {
                const recipeName = document.getElementById('editedRecipeNameID').value;
                self.finishEditRecipe(recipeName, position);
            }
        });
    }

    // deletes a recipe from the local storage
    deleteRecipeForGood(recipeName) {

        this.modelRecipes.deleteRecipe(recipeName);

        location.reload();
    }

    // this is the method called by the "Finish" button while editing a recipe(in other words, finish editing)
    finishEditRecipe(recipeName, position) {
        // getting all the ingredients names from the recipe
        const ingredientNames = document.getElementsByClassName('editedRecipeIngredientNameClass');
        let newIngredientNames = [];
        for (let i = 0; i < ingredientNames.length; i++) {
            newIngredientNames.push(ingredientNames[i].value);
        }

        // getting all the ingredient quantities from the recipe
        const ingredientQuantities = document.getElementsByClassName('editedRecipeIngredientQuantityClass');
        let newIngredientQuantities = [];
        for (let i = 0; i < ingredientQuantities.length; i++) {
            newIngredientQuantities.push(ingredientQuantities[i].value);
        }

        const recipeDescription = document.getElementById('editRecipeDescriptionID').value;

        this.modelRecipes.editRecipe(recipeName, newIngredientNames, newIngredientQuantities, recipeDescription, position);

        location.reload();
    }

    // generate a weekly menu from our current recipe list
    generateMenu() {
        const recipes = this.modelRecipes.getItems();

        // create the weekly menu table head
        const weeklyMenu = document.getElementById('contentGMenuID');
        const weeklyMenuTable = document.createElement('table');
        weeklyMenuTable.innerHTML = this.view.renderMenuHeading();
        
        // randomly pick from the list of recipes and add them to the menu
        // if (recipes.length >= 7) {
            for (let i = 0; i < 7; i++) {
                let randomRecipe = recipes[Math.floor(Math.random()*recipes.length)];
                const newRecipeEntry = this.view.renderweekyRecipe(randomRecipe.name, i);
                weeklyMenuTable.appendChild(newRecipeEntry);

                // store the newly generated menu as we create it
                this.modelMenus.storeCurrentMeal(randomRecipe.name, i);
            }
        // } else {
        //     for (let i = 0; i < recipes.length; i++) {
        //         let randomRecipe = recipes[Math.floor(Math.random()*recipes.length)];
        //         const newRecipeEntry = this.view.renderweekyRecipe(randomRecipe.name, i);
        //         weeklyMenuTable.appendChild(newRecipeEntry);

        //         // store the newly generated menu as we create it
        //         this.modelMenus.storeCurrentMeal(randomRecipe.name, i);
        //     }
        // }

        weeklyMenu.appendChild(weeklyMenuTable);

        // store the weekly meal in the local storage
        this.modelMenus.storeMeal();
    }

    // view current menu
    viewMenu() {
        const menus = this.modelMenus.getMeals();

        // create the weekly menu table head
        const weeklyMenu = document.getElementById('contentVMenuID');
        const weeklyMenuTable = document.createElement('table');
        weeklyMenuTable.innerHTML = this.view.renderMenuHeading();

        for (let i = 0; i < menus.length; i++) {
            const newRecipeEntry = this.view.renderweekyRecipe(menus[i].meal, i);
            weeklyMenuTable.appendChild(newRecipeEntry);
        }

        weeklyMenu.appendChild(weeklyMenuTable);
    }
}

